# ReasonReact Code-Splitting Demo

As your React application grows bigger, it's time to think about cutting the
bundle into smaller pieces, so that the users of your website could enjoy a
better experience.

This project shows how to split a React application by routes in ReasonML.

Interactive demo:
[reason-react-code-splitting.surge.sh](http://reason-react-code-splitting.surge.sh/)

## 1. Configuration

_Only the bits that interest us are included._

package.json

```json
{
  "dependencies": {
    "react": "^16.8.1",
    "react-dom": "^16.8.1",
    "reason-react": ">=0.7.0"
  },
  "devDependencies": {
    "bs-platform": "^5.0.6",
    "html-webpack-plugin": "^3.2.0",
    "webpack": "^4.0.1",
    "webpack-cli": "^3.1.1"
  }
}
```

bsconfig.json

```json
{
  "bs-dependencies": ["reason-react"],
  "reason": {
    "react-jsx": 3
  },
  "suffix": ".bs.js"
}
```

webpack.config.js

```javascript
const HtmlWebpackPlugin = require("html-webpack-plugin");

module.exports = {
  entry: {
    app: "./src/Index.bs.js"
  },
  output: {
    path: path.join(__dirname, "build"),
    filename: "[name]-[chunkhash].bundle.js",
    chunkFilename: "[name]-[chunkhash].bundle.js"
  },
  optimization: {
    runtimeChunk: "single",
    splitChunks: {
      chunks: "all"
    }
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: "src/index.html"
    })
  ]
};
```

## 2. `import` and `React.lazy` bindings

In order to dynamically import our components, let's first create bindings for
`import` and `React.lazy` functions.

We'll also define a helper function that simplifies using the two bindings.

```reasonml
/* Lazy.re */

[@bs.val] external import: string => Js.Promise.t('a) = "import";

[@bs.module "react"]
external lazy_: (unit => Js.Promise.t('a)) => 'a = "lazy";

let load = moduleName => lazy_(() => import({j|./$moduleName.bs.js|j}));
```

## 3. Custom `React.createElementVariadic` binding

In order to have fully checked code, we must declare our own
`createElementVariadic` function. `ReasonReact`'s `createElementVariadic`
accepts any value as props which can lead to a broken application without you
knowing because the compiler says everything is correct. One of the reasons we
use ReasonML is its powerful type system and we should take advantage of it
whenever we can.

With the official `createElementVariadic` function, whenever you forget to add a
prop, the `makeProps` function generated by `ReasonReact`'s PPX is partially
applied. The value in this case is a `function` not a JS object that the
component wants.

Our `createElementVariadic` function will accept `Js.t('props)` instead of just
`'props`:

```reasonml
/* External.re */
module React = {
  [@bs.splice] [@bs.module "react"]
  external createElementVariadic:
    (React.component(Js.t('props)), Js.t('props), array(React.element)) =>
    React.element =
    "createElement";
};
```

## 4. App component

The `App` component drives the application. Whenever the user clicks on one of
the navigation buttons, the selected page component will be loaded dynamically.

Most important parts of the `App` component are:

```reasonml
External.React.createElementVariadic(
  Lazy.loadPage("HomePage"),
  HomePage.makeProps(~text="Home", ()),
  [||],
)
```

and

```reasonml
<React.Suspense fallback=React.null> page </React.Suspense>
```

Normally you would use JSX to build component hierarchies, but in our case it
falls short. By using `External.React.createElementVariadic` in its raw form, we
can specify our own custom `component` argument which is an `import` call
wrapped in `React.lazy`.

```reasonml
/* App.re */

type page =
  | Home
  | Services
  | Contact;

let setPage = page =>
  ReasonReactRouter.push(
    switch (page) {
    | Home => "/"
    | Services => "/services"
    | Contact => "/contact"
    },
  );

[@react.component]
let make = () => {
  let url = ReasonReactRouter.useUrl();

  let page =
    switch (url.path) {
    | [] =>
      React.createElementVariadic(
        Lazy.loadPage("HomePage"),
        HomePage.makeProps(~text="Home", ()),
        [||],
      )
    | ["services"] =>
      React.createElementVariadic(
        Lazy.loadPage("ServicesPage"),
        ServicesPage.makeProps(),
        [||],
      )
    | ["contact"] =>
      React.createElementVariadic(
        Lazy.loadPage("ContactPage"),
        ContactPage.makeProps(),
        [||],
      )
    | _ =>
      React.createElementVariadic(
        Lazy.loadPage("NotFoundPage"),
        NotFoundPage.makeProps(),
        [||],
      )
    };

  <div className="container">
    <div className="menu">
      <div className="menuItem" onClick={_ => setPage(Home)}>
        "Home"->React.string
      </div>
      <div className="menuItem" onClick={_ => setPage(Services)}>
        "Services"->React.string
      </div>
      <div className="menuItem" onClick={_ => setPage(Contact)}>
        "Contact"->React.string
      </div>
    </div>
    <div className="page">
      <React.Suspense fallback=React.null> page </React.Suspense>
    </div>
  </div>;
};
```

## 5. Page components

The application has 4 pages: `HomePage`, `ServicesPage`, `ContactPage` and
`NotFoundPage`. The important bit here is to include `let default = make` for
every component that is being loaded lazily. This will set the `make` function
as the default export.

```reasonml
/* HomePage.re */
[@react.component]
let make = (~text) => <div> text->React.string </div>;

let default = make; /* This is important! */


/* ServicesPage.re */
[@react.component]
let make = () => <div> "Services"->React.string </div>;

let default = make;


/* ContactPage.re */
[@react.component]
let make = () => <div> "Contact"->React.string </div>;

let default = make;


/* NotFoundPage.re */
[@react.component]
let make = () => <div> "Not Found"->React.string </div>;

let default = make;
```

## 6. Existing solutions

- [reason-loadable](https://github.com/kMeillet/reason-loadable):
  I previously used a solution similar to `reason-loadable`, but in my opinion
  it's too complex. It probably suffers from the flaw described in `3. Custom React.createElementVariadic binding`. I decided to dig deeper to make the
  implementation as simple as possible and this is the solution I came up with.

That's about it. Have fun splitting modules!

## Instructions

```
yarn install
yarn run build
yarn run server
```

## License

[MIT](./LICENSE)
